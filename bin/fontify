#!/usr/bin/env bash
# shellcheck shell=bash #disable=2034
# a script by vlk to do a thing.

declare -r ME="${0##*/}"
declare -r PROGNAME="${ME%%.*}"
declare -r PROGVERS='0.0.1'

## Copyright (C) 2023 vlk
## This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.
## This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
## See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

# function to put bash in either safe or unsafe mode
__mode() {
    if [[ "${1:-}" == '--unsafe-mode' ]]; then
        set +euo pipefail
    else
        set -euo pipefail
        IFS=$'\n\t'
    fi
}

# determine a safe output to print to
declare -i MYTTY=0
declare -i PIPE_BOTH=0
declare -i PIPEOUTPUT=0
if [[ -t 1 && -t 2 ]]; then
    MYTTY=1
elif [[ -t 1 && ! -t 2 ]]; then
    MYTTY=1
    PIPEOUTPUT=2
elif [[ ! -t 1 && -t 2 ]]; then
    MYTTY=2
    PIPEOUTPUT=1
else
    PIPE_BOTH=1
fi
declare -r MYTTY
declare -r PIPEOUTPUT
declare -r PIPE_BOTH

_log() {
    # split content with IFS
    local IFS=$'\n'
    local content="$*"
    ((MYTTY)) && echo "[0m$content[0m" >&"$MYTTY"
    if ((PIPE_BOTH)); then
        echo "$content"
        echo "$content" >&2
    elif ((PIPEOUTPUT)); then
        echo "$content" >&"$PIPEOUTPUT"
    fi
}

# panic function, to gracefully tell the user what went wrong
_panic() {
    _log "[$ME] panic!" "$@"
    # uncomment if you want to send a desktop notification
    # [[ -n ${DISPLAY:-} || -n ${WAYLAND_DISPLAY:-} ]] && notify-send -i 'dialog-error' -a "${0##*/}" 'Panic!' "$content"
    exit 1
}

# strip color function, idk it's useful ig lol
strip_color() {
    # Strip all occurences of ansi color strings from input strings
    local ansi_regex='\[([0-9;]+)m'
    local i
    local -a matches=()
    for i in "$@"; do
        while [[ $i =~ $ansi_regex ]]; do
            matches+=("${BASH_REMATCH[1]}")
            i=${i//${BASH_REMATCH[0]}/}
        done
        echo "$i"
    done
}

# some useful characters
TAB=$'\t'
LF=$'\n'

# box-drawing characters, powerline characters, and some other nerd font icons, useful for output
#â•­â”€â”¬â”€â•®â”‚ î‚ºî‚¼ î‚¾î‚¸ îƒ‘ ó°€„ î‚  ó°•ˆ
#â”œâ”€â”¼â”€â”¤â”‚ î‚²î‚° îƒ‡îƒ† ó°“Ž ó°˜³ îˆ« ó°‚½
#â•°â”€â”´â”€â•¯â”‚ î‚¶î‚´ îƒ‚îƒ€ ó°…Ÿ ó°˜² ó°£‡ ó°£›
# ó°¬›ó°¬ó°¬Œ ó°¬˜ó°¬œó°¬ó°¬Šó°¬’ ó°¬‰ó°¬™ó°¬–ó°¬žó°¬• ó°¬ó°¬–ó°¬Ÿ ó°¬‘ó°¬œó°¬”ó°¬—ó°¬Œó°¬‹ ó°¬–ó°¬ó°¬Œó°¬™ ó°¬›ó°¬ó°¬Œ ó°¬“ó°¬ˆó°¬¡ó°¬  ó°¬‹ó°¬–ó°¬Ž

# set it in safe mode, a reasonable default
__mode

# add main system binary folder to path if it isn't there already
[[ ":${PATH:-}:" != *':/usr/bin:'* ]] && PATH="${PATH:-}:/usr/bin"

# check for dependencies
declare -a faildeps=()
for i in fzf; do
    command -v $i &>/dev/null || faildeps+=("$i")
done
((${#faildeps[@]})) && _panic 'Missing dependencies' "${faildeps[@]}"

declare -a alphabet_lowercase=(a b c d e f g h i j k l m n o p q r s t u v w x y z)
declare -a alphabet_uppercase=(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z)

filled_str='ó°¬ˆó°¬‰ó°¬Šó°¬‹ó°¬Œó°¬ó°¬Žó°¬ó°¬ó°¬‘ó°¬’ó°¬“ó°¬”ó°¬•ó°¬–ó°¬—ó°¬˜ó°¬™ó°¬šó°¬›ó°¬œó°¬ó°¬žó°¬Ÿó°¬ ó°¬¡'
# declare -A font_filled
outline_str='ó°¯«ó°¯®ó°¯±ó°¯´ó°¯·ó°¯ºó°¯½ó°°€ó°°ƒó°°†ó°°‰ó°°Œó°°ó°°’ó°°•ó°°˜ó°°›ó°°žó°°¡ó°°¤ó°°§ó°°ªó°°­ó°°°ó°°³ó°°¶'
# declare -A font_outline

# nerd-rofi.sh --stderr 2>&1 | grep -P 'md-(alpha|numeric)_[a-z0-9]_'
# grep -E '(box|circle)(|_(multiple(|_outline)|outline))'
# md-numeric_7_box ó°Ž¶
# md-numeric_7_box_multiple ó°¼•
# md-numeric_7_box_multiple_outline ó°Ž·
# md-numeric_7_box_outline ó°Ž¸
# md-numeric_7_circle ó°²¬
# md-numeric_7_circle_outline ó°²­

# alpha, numeric

fontrefstr=filled # filled, outline
declare -i done_processing=0
for i in "$@"; do
    if ((done_processing)); then
        texts+=("$i")
    else
        case "${i:=}" in
        --filled*)
            fontrefstr=filled
            ;;
        --outline*)
            fontrefstr=outline
            ;;
        --)
            done_processing=1
            ;;
        *)
            texts+=("$i")
            ;;
        esac
    fi
done
# declare -n font=font_$fontrefstr
declare -n fontstr=${fontrefstr}_str

declare -A font

fontstr="$fontstr$fontstr"
for i in "${alphabet_lowercase[@]}" "${alphabet_uppercase[@]}"; do
    font[$i]="${fontstr::1}"
    fontstr="${fontstr:1}"
done

for j in "${texts[@]}"; do
    for i in "${alphabet_lowercase[@]}" "${alphabet_uppercase[@]}"; do
        j="${j//$i/"${font[$i]}"}"
    done
    echo "$j"
done
