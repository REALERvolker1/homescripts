#!/usr/bin/zsh
# shellcheck shell=bash
# shellcheck disable=SC2296

if [ -z "${ZSH_VERSION:-$BASH_VERSION}" ] || ! expr "$-" : '.*i' >/dev/null; then
    return 1
    exit 1
fi

[ -n "${BASH_VERSION:-}" ] && {

    echo "vlk bash prompt is unfinished"
    __vlkprompt_ps1="] \w ]"
    [[ "$HOSTNAME" != "$CURRENT_HOSTNAME" ]] && __vlkprompt_ps1="] \H $__vlkprompt_ps1"

    PS1="$__vlkprompt_ps1"

    __vlk_precmd () {
        local err="$?"
        if sudo -vn &>/dev/null && [ -z "${DISTROBOX_ENTER_PATH:-}" ]; then
            sudostr="# "
        else
            sudostr="$ "
        fi
        if ((err != 0)); then
            errstr="[$err"
        else
            errstr=''
        fi
        PS1="${errstr}$__vlkprompt_ps1 $sudostr"
    }

    PROMPT_COMMAND+=('__vlk_precmd')

    command_not_found_handle () {
        echo "[bash] Error, command '$1' does not exist!"
        return 127
    }

    return 0
}

declare -A icons colorsbg colorsfg colorstx content set ends index

icons[cwd_ro]=
icons[cwd_rw]=
icons[git]=󰊢
icons[vim]=
icons[err]=󰅗
icons[job]=󱜯
icons[hos]=󰟀
content[sud_end]=' '
content[end]=

case "$ICON_TYPE" in
powerline)
    content[end]=
    ;;
fallback)
    icons[cwd_ro]='-'
    icons[cwd_rw]='&'
    icons[git]='G'
    icons[vim]='V'
    icons[err]='X'
    icons[job]='J'
    icons[hos]='H'
    content[sud_end]=']#'
    content[end]=']'
    ;;
esac

# if ((VLKPROMPT_COLOR_OVERRIDE < 9)); then
if (($(tput colors) < 255)); then
    set[fg_esc]='\x1b[3'
    set[bg_esc]='\x1b[4'
    set[tx_esc]='\x1b[1;3'

    colorstx[l]=7
    colorstx[d]=0

    colorsfg[cwd]=4
    colorsfg[git]=5
    colorsfg[vim]=2
    colorsfg[err]=1
    colorsfg[job]=3
    colorsfg[hos]=4
    colorsfg[sud]=6
    colorsfg[ps2]=5
    colorsfg[ps3]=5

    colorsbg[cwd]=4
    colorsbg[git]=5
    colorsbg[vim]=2
    colorsbg[err]=1
    colorsbg[job]=3
    colorsbg[hos]=4
    colorsbg[sud]=6
    colorsbg[ps2]=5
    colorsbg[ps3]=5

else

    set[fg_esc]='\x1b[38;5;'
    set[bg_esc]='\x1b[48;5;'
    set[tx_esc]='\x1b[1;38;5;'

    colorstx[l]=255
    colorstx[d]=232

    colorsfg[cwd]=33
    colorsfg[git]=141
    colorsfg[vim]=120
    colorsfg[err]=52
    colorsfg[job]=172
    colorsfg[hos]=18
    colorsfg[sud]=196
    colorsfg[ps2]=93
    colorsfg[ps3]=89

    colorsbg[cwd]=33
    colorsbg[git]=141
    colorsbg[vim]=120
    colorsbg[err]=52
    colorsbg[job]=172
    colorsbg[hos]=18
    colorsbg[sud]=196
    colorsbg[ps2]=93
    colorsbg[ps3]=89

fi
set[end_esc]='m'

set[o]='%{'
set[c]='%}'
set[sgr]='%k%f%b%u%s'

set[fg_esc]='%F{'
set[bg_esc]='%K{'
set[tx_esc]='%B%F{'
set[end_esc]='}'
set[o]=''
set[c]=''


for i in "${(@k)colorsbg}"; do
    declare "colorsbg[$i]=${set[o]}${set[bg_esc]}${colorsbg[$i]}${set[end_esc]}${set[c]}"
done
for i in "${(@k)colorsfg}"; do
    declare "colorsfg[$i]=${set[o]}${set[fg_esc]}${colorsfg[$i]}${set[end_esc]}${set[c]}"
done
for i in "${(@k)colorstx}"; do
    declare "colorstx[$i]=${set[o]}${set[tx_esc]}${colorstx[$i]}${set[end_esc]}${set[c]}"
done

# for bash
# [[ "$(declare -p PROMPT_COMMAND 2>&1)" =~ "declare -a" ]] && PROMPT_COMMAND+=('__function')

index[transient]=130
index[sudo]=135
index[writable]=136
index[git]=137
index[vim]=138

icons[cwd]="%(${index[writable]}V.${icons[cwd_rw]}.${icons[cwd_ro]})"

for i in "${(@k)icons}"; do
    declare "icons[$i]=%(${index[transient]}V.. ${icons[$i]})"
done

set[has_job]='1j'
set[has_no_err]='0?'

content[newline]="${set[sgr]}%(${index[transient]}V..
)"

if [[ "$HOSTNAME" != "$CURRENT_HOSTNAME" ]]; then
    content[hostname]="${colorsbg[hos]}${colorstx[l]} $HOSTNAME ${set[sgr]}"
else
    content[hostname]=''
fi

content[job]="%(${set[has_job]}.${set[sgr]}${colorsbg[job]}${colorstx[d]}${icons[job]} %j ${set[sgr]}.)"
content[err]="%(${set[has_no_err]}..${set[sgr]}${colorsbg[err]}${colorstx[l]}${icons[err]} %? ${set[sgr]})"

content[cwd_icon]="%(${index[vim]}V.${colorsbg[vim]}${colorstx[d]}${icons[vim]}.%(${index[git]}V.${colorsbg[git]}${colorstx[d]}${icons[git]}.${colorsbg[cwd]}${colorstx[l]}${icons[cwd]}))"
content[cwd]="${set[sgr]}${content[cwd_icon]} %\$((COLUMNS / 2))<..<%~ ${set[sgr]}"
content[sudo]="%(${index[sudo]}V.${set[sgr]}${colorsbg[sud]} ${set[sgr]}${colorsfg[sud]}${content[sud_end]}${set[sgr]}.)"

ends[dir_bg]="%(${index[vim]}V.${colorsbg[vim]}.%(${index[git]}V.${colorsbg[git]}.${colorsbg[cwd]}))"

ends[job]="%(${index[transient]}V..%(${set[has_job]}.${colorsfg[job]}%(${set[has_no_err]}.${ends[dir_bg]}.${colorsbg[err]})${content[end]}.))"
ends[err]="%(${index[transient]}V..%(${set[has_no_err]}..${colorsfg[err]}${ends[dir_bg]}${content[end]}))"
ends[cwd]="%(${index[sudo]}V.${colorsbg[sud]}.)%(${index[vim]}V.${colorsfg[vim]}.%(${index[git]}V.${colorsfg[git]}.${colorsfg[cwd]}))${content[end]}${set[sgr]}"

PS1="${content[newline]}${content[hostname]}\
${content[job]}${ends[job]}\
${content[err]}${ends[err]}\
${content[cwd]}${ends[cwd]}${content[sudo]} "

# PS2="${colorsbg[ps2]}${colorstx[l]} %_ ${set[sgr]}${colorsfg[ps2]}\
# %(${index[sudo]}V.${colorsbg[sud]}${content[end]} ${set[sgr]}${colorsfg[sud]}${content[sud_end]}.${content[end]})${set[sgr]} "

for i in 2 3; do
    declare "PS$i=${set[sgr]}${colorsbg[ps$i]}${colorstx[l]} %_ ${set[sgr]}${colorsfg[ps$i]}%(${index[sudo]}V.${colorsbg[sud]}${content[end]} ${set[sgr]}${colorsfg[sud]}${content[sud_end]}.${content[end]})${set[sgr]} "
done

SUDO_PROMPT="$(print -P "${colorsbg[sud]}${colorstx[l]} entering sudo mode ${set[sgr]}${colorsfg[sud]}${content[sud_end]}${set[sgr]}") "
COMMAND_NOT_FOUND_STR="$(print -P "${colorsbg[sud]}${colorstx[d]}${icons[err]} ERROR ${set[sgr]}${colorsfg[sud]}${colorsbg[err]}${content[end]}${colorstx[l]}%b Command '%B+%b' not found ${set[sgr]}${colorsfg[err]}${content[end]}${set[sgr]}")"

unset icons colorsbg colorsfg colorstx content set ends

# __vlk_precmd () {
#     if sudo -vn &>/dev/null; then # sudo
#         psvar[${index[sudo]}]=1
#     else
#         psvar[${index[sudo]}]=''
#     fi
#     if [ -w "$PWD" ]; then # dir icon
#         psvar[${index[writable]}]=1
#     else
#         psvar[${index[writable]}]=''
#     fi
#     if git status &>/dev/null ; then # git color
#         psvar[${index[git]}]=1
#     else
#         psvar[${index[git]}]=''
#     fi
#     psvar[${index[vim]}]='' # vicmd
# }
# export -U precmd_functions
# precmd_functions+=('__vlk_precmd')

if [ -z "${DISTROBOX_ENTER_PATH:-}" ]; then
    __vlk_precmd_sudo () {
        if sudo -vn &>/dev/null; then # sudo
            psvar[${index[sudo]}]=1
        else
            psvar[${index[sudo]}]=''
        fi
    }
else
    __vlk_precmd_sudo () { :; }
fi
__vlk_precmd_writable () {
    if [ -w "$PWD" ]; then # dir icon
        psvar[${index[writable]}]=1
    else
        psvar[${index[writable]}]=''
    fi
}
__vlk_precmd_git () {
    if git status &>/dev/null ; then # git color
        psvar[${index[git]}]=1
    else
        psvar[${index[git]}]=''
    fi
}
__vlk_precmd () {
    psvar[${index[vim]}]='' # vicmd
}
export -U precmd_functions
precmd_functions+=('__vlk_precmd' '__vlk_precmd_sudo' '__vlk_precmd_writable' '__vlk_precmd_git')

function zle-line-init zle-keymap-select {
    if [[ "$KEYMAP" == vicmd ]]; then
        psvar[${index[vim]}]=1
    else
        psvar[${index[vim]}]=''
    fi
    zle reset-prompt
}
zle -N zle-keymap-select

__vlk-zle-line-init () {
    [[ "$CONTEXT" == 'start' ]] || return 0
    (( $+zle_bracketed_paste )) && print -r -n - $zle_bracketed_paste[1]
    zle recursive-edit
    local -i ret=$?
    (( $+zle_bracketed_paste )) && print -r -n - $zle_bracketed_paste[2]
    if [[ "$ret" == 0 && "$KEYS" == $'\4' ]]; then
        psvar[${index[transient]}]=1
        zle reset-prompt
        exit
    fi
    psvar[${index[transient]}]=1
    zle reset-prompt
    psvar[${index[transient]}]=''
    if (( ret )); then
        zle send-break
    else
        zle accept-line
    fi
    return ret
}

zle -N zle-line-init __vlk-zle-line-init

command_not_found_handler () { # in bash, called command_not_found_handle
    echo "${COMMAND_NOT_FOUND_STR//+/$1}"
    return 127
}
