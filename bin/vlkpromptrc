#!/usr/bin/zsh
# shellcheck disable=SC2296

[[ "$-" == *i* && -z $BASH_VERSION ]] || {
    return 1
    exit 1
}

declare -A icons colors colorsbg colorsfg colorstx content set ends index

icons[cwd_ro]=
icons[cwd_rw]=
icons[git]=󰊢
icons[vim]=
icons[err]=󰅗
icons[job]=󱜯
icons[hos]=󰟀
icons[log]=󰌆
content[sud_end]=' '
content[end]=
content[end_r]=

case "$ICON_TYPE" in
powerline)
    content[end]=
    content[end_r]=
    ;;
fallback)
    icons[cwd_ro]='-'
    icons[cwd_rw]='&'
    icons[git]='G'
    icons[vim]='V'
    icons[err]='X'
    icons[job]='J'
    icons[hos]='H'
    icons[log]='l'
    content[sud_end]=']#'
    content[end]=']'
    content[end_r]='['
    ;;
esac

if (($(tput colors) < 255)); then

    set[ansi]=''

    colorstx[l]=7
    colorstx[d]=0

    colors[cwd]=4
    colors[git]=5
    colors[vim]=2
    colors[err]=1
    colors[job]=3
    colors[hos]=4
    colors[sud]=6
    colors[ps2]=5
    colors[ps3]=5

else

    set[ansi]='8;5;'
    colorstx[l]=255
    colorstx[d]=232

    colors[cwd]=33
    colors[git]=141
    colors[vim]=120
    colors[err]=52
    colors[job]=172
    colors[hos]=18
    colors[sud]=196
    colors[ps2]=93
    colors[ps3]=89

fi

COMMAND_NOT_FOUND_STR="\e[0m\e[4${set[ansi]}${colors[sud]}m\e[1;3${set[ansi]}${colorstx[d]}m \
${icons[err]} ERROR \e[0m\e[3${set[ansi]}${colors[sud]}m\e[4${set[ansi]}${colors[err]}m${content[end]} \
\e[3${set[ansi]}${colorstx[l]}mCommand '\e[1m+\e[0m\e[4${set[ansi]}${colors[err]}m\e[3${set[ansi]}${colorstx[l]}m' \
not found \e[0m\e[3${set[ansi]}${colors[err]}m${content[end]}\e[0m"

command_not_found_handler () {
    echo -e "${COMMAND_NOT_FOUND_STR//+/$1}"
    return 127
}

set[sgr]='%k%f%b%u%s'

index[transient]=130
index[sudo]=135
index[writable]=136
index[git]=137
index[vim]=138

icons[cwd]="%(${index[writable]}V.${icons[cwd_rw]}.${icons[cwd_ro]})"

eval "$(
    printf "declare 'icons[%s]=%%(${index[transient]}V.. %s)'\n" "${(@kv)icons}"
    printf "declare 'colorsbg[%s]=%%K{%s}'\n" "${(@kv)colors}"
    printf "declare 'colorsfg[%s]=%%F{%s}'\n" "${(@kv)colors}"
    printf "declare 'colorstx[%s]=%%B%%F{%s}'\n" "${(@kv)colorstx}"
)"

set[has_job]='1j'
set[has_no_err]='0?'

content[newline]="${set[sgr]}%(${index[transient]}V..
)"

set[color_next]=''

if [[ "$HOSTNAME" != "$CURRENT_HOSTNAME" ]]; then
    content[hostname]="${colorsbg[hos]}${colorstx[l]} $HOSTNAME ${set[sgr]}"
    set[color_next]="${colorsbg[hos]}"
else
    content[hostname]=''
    set[color_next]=''
fi

if [[ "$-" =~ l ]]; then
    content[login]="${colorsbg[ps2]}${colorstx[l]}${icons[log]} ${set[sgr]}"
else
    content[login]=''
fi

content[job]="%(${set[has_job]}.${set[sgr]}${colorsbg[job]}${colorstx[d]}${icons[job]} %j ${set[sgr]}.)"
content[err]="%(${set[has_no_err]}..${set[sgr]}${colorsbg[err]}${colorstx[l]}${icons[err]} %? ${set[sgr]})"

content[cwd_icon]="%(${index[vim]}V.${colorsbg[vim]}${colorstx[d]}${icons[vim]}.%(${index[git]}V.${colorsbg[git]}${colorstx[d]}${icons[git]}.${colorsbg[cwd]}${colorstx[l]}${icons[cwd]}))"
content[cwd]="${set[sgr]}${content[cwd_icon]} %\$((COLUMNS / 2))<..<%~ ${set[sgr]}"
content[sudo]="%(${index[sudo]}V.${set[sgr]}${colorsbg[sud]} ${set[sgr]}${colorsfg[sud]}${content[sud_end]}${set[sgr]}.)"

ends[dir_bg]="%(${index[vim]}V.${colorsbg[vim]}.%(${index[git]}V.${colorsbg[git]}.${colorsbg[cwd]}))"

ends[job]="%(${index[transient]}V..%(${set[has_job]}.${colorsfg[job]}%(${set[has_no_err]}.${ends[dir_bg]}.${colorsbg[err]})${content[end]}.))"
ends[err]="%(${index[transient]}V..%(${set[has_no_err]}..${colorsfg[err]}${ends[dir_bg]}${content[end]}))"
ends[cwd]="%(${index[sudo]}V.${colorsbg[sud]}.)%(${index[vim]}V.${colorsfg[vim]}.%(${index[git]}V.${colorsfg[git]}.${colorsfg[cwd]}))${content[end]}${set[sgr]}"

PS1="${content[newline]}${content[login]}${content[hostname]}\
${content[job]}${ends[job]}\
${content[err]}${ends[err]}\
${content[cwd]}${ends[cwd]}${content[sudo]} "

for __vlkprompt_i in 2 3; do
    declare "PS${__vlkprompt_i}=${set[sgr]}${colorsbg[ps$__vlkprompt_i]}${colorstx[l]} %_ ${set[sgr]}${colorsfg[ps$__vlkprompt_i]}%(${index[sudo]}V.${colorsbg[sud]}${content[end]} ${set[sgr]}${colorsfg[sud]}${content[sud_end]}.${content[end]})${set[sgr]} "
done

SUDO_PROMPT="$(print -P "${colorsbg[sud]}${colorstx[l]} entering sudo mode ${set[sgr]}${colorsfg[sud]}${content[sud_end]}${set[sgr]}") "

unset icons colorsbg colorsfg colorstx colors content set ends __vlkprompt_i

__vlk_precmd() {
    git status &>/dev/null && psvar[${index[git]}]=1
    [[ -w "$PWD" ]] && psvar[${index[writable]}]=1
    [[ -z $DISTROBOX_ENTER_PATH ]] && sudo -vn &>/dev/null && psvar[${index[sudo]}]=1
}
export -U precmd_functions=('__vlk_precmd')

function zle-line-init zle-keymap-select {
    if [[ "$KEYMAP" == vicmd ]]; then
        psvar[${index[vim]}]=1
    else
        psvar[${index[vim]}]=''
    fi
    zle reset-prompt
}
zle -N zle-keymap-select

__vlk-zle-line-init () {
    [[ "$CONTEXT" == 'start' ]] || return 0
    (( $+zle_bracketed_paste )) && print -r -n - "${zle_bracketed_paste[1]}"
    zle recursive-edit
    local -i ret="$?"
    (( $+zle_bracketed_paste )) && print -r -n - "${zle_bracketed_paste[2]}"
    if [[ "$ret" == 0 && "$KEYS" == $'\4' ]]; then
        psvar[${index[transient]}]=1
        zle reset-prompt
        exit
    fi
    psvar[${index[transient]}]=1
    zle reset-prompt
    psvar=()
    if (( ret )); then
        zle send-break
    else
        zle accept-line
    fi
    return ret
}

zle -N zle-line-init __vlk-zle-line-init

